# 3.2 Job Filtering System Implementation Plan

## Overview
Implement a comprehensive filtering system for job listings that allows users to filter by location and job type with URL state management for shareable filter combinations.

## Technical Requirements

### 1. Filter State Management
- **File**: `src/hooks/use-job-filters.ts`
- **Custom Hook**: Manages filter state and URL synchronization
```typescript
interface JobFilters {
  location: string[]
  jobType: ('Full-Time' | 'Part-Time' | 'Contract')[]
  searchQuery: string
}

export function useJobFilters() {
  const [filters, setFilters] = useState<JobFilters>({
    location: [],
    jobType: [],
    searchQuery: ''
  })
  
  const updateFilters = (newFilters: Partial<JobFilters>) => {
    // Update URL params
    // Update local state
  }
  
  return { filters, updateFilters, resetFilters }
}
```

### 2. Database Query Enhancement
- **File**: `src/lib/database/jobs.ts`
- **Function**: `getFilteredJobs(filters: JobFilters)`
```typescript
export async function getFilteredJobs(filters: JobFilters): Promise<Job[]> {
  let query = supabase
    .from('jobs')
    .select('*')
    .order('created_at', { ascending: false })
  
  if (filters.location.length > 0) {
    query = query.in('location', filters.location)
  }
  
  if (filters.jobType.length > 0) {
    query = query.in('job_type', filters.jobType)
  }
  
  if (filters.searchQuery) {
    query = query.or(`title.ilike.%${filters.searchQuery}%,company.ilike.%${filters.searchQuery}%,description.ilike.%${filters.searchQuery}%`)
  }
  
  const { data, error } = await query
  if (error) throw error
  return data || []
}
```

### 3. Filter Components

#### Location Filter
- **File**: `src/components/jobs/filters/location-filter.tsx`
- **Features**:
  - Multi-select dropdown or checkbox list
  - Autocomplete functionality with existing locations
  - Clear individual selections
```typescript
interface LocationFilterProps {
  selectedLocations: string[]
  availableLocations: string[]
  onLocationChange: (locations: string[]) => void
}
```

#### Job Type Filter
- **File**: `src/components/jobs/filters/job-type-filter.tsx`
- **Features**:
  - Checkbox group for job types
  - Visual badges showing active filters
  - Single or multi-select capability
```typescript
interface JobTypeFilterProps {
  selectedTypes: JobType[]
  onTypeChange: (types: JobType[]) => void
}
```

#### Search Filter
- **File**: `src/components/jobs/filters/search-filter.tsx`
- **Features**:
  - Text input with debounced search
  - Search icon and clear button
  - Placeholder text guidance
```typescript
interface SearchFilterProps {
  query: string
  onQueryChange: (query: string) => void
  placeholder?: string
}
```

### 4. Filter Container Component
- **File**: `src/components/jobs/filters/job-filters.tsx`
- **Features**:
  - Responsive layout (horizontal on desktop, collapsible on mobile)
  - Active filter count indicator
  - Reset all filters button
  - Filter persistence in URL

### 5. Enhanced Jobs Page
- **File**: `src/app/jobs/page.tsx` (updated)
- **Features**:
  - URL parameter handling for initial filter state
  - Server-side filtering support
  - Client-side filter updates with optimistic UI

## URL State Management

### 1. URL Parameter Structure
```
/jobs?location=Remote,New+York&jobType=Full-Time,Contract&search=developer
```

### 2. URL Serialization
- **File**: `src/lib/utils/url-filters.ts`
```typescript
export function filtersToUrlParams(filters: JobFilters): URLSearchParams {
  const params = new URLSearchParams()
  
  if (filters.location.length > 0) {
    params.set('location', filters.location.join(','))
  }
  
  if (filters.jobType.length > 0) {
    params.set('jobType', filters.jobType.join(','))
  }
  
  if (filters.searchQuery) {
    params.set('search', filters.searchQuery)
  }
  
  return params
}

export function urlParamsToFilters(searchParams: URLSearchParams): JobFilters {
  return {
    location: searchParams.get('location')?.split(',').filter(Boolean) || [],
    jobType: (searchParams.get('jobType')?.split(',').filter(Boolean) as JobType[]) || [],
    searchQuery: searchParams.get('search') || ''
  }
}
```

## UI/UX Specifications

### Desktop Layout
```
Filter Bar Layout:
┌─────────────────────────────────────────────────────────────┐
│ Search: [_______________] Location: [▼] Type: [☑][☑][☑] Reset│
│ Active Filters: [Remote ×] [Full-Time ×] [Contract ×]       │
└─────────────────────────────────────────────────────────────┘
```

### Mobile Layout
```
Mobile Filter Layout:
┌─────────────────────────┐
│ [🔍] Search             │
│ [📍] Filters (2) ▼      │ ← Collapsible
└─────────────────────────┘
When expanded:
┌─────────────────────────┐
│ Search: [_____________] │
│ Location:               │
│ ☑ Remote  ☑ New York   │
│ ☑ London  ☑ San Fran   │
│ Job Type:               │
│ ☑ Full-Time             │
│ ☑ Part-Time             │
│ ☑ Contract              │
│ [Apply Filters] [Reset] │
└─────────────────────────┘
```

### Filter States
- **Active Filter Badges**: Show selected filters with remove option
- **Filter Count**: Display number of active filters
- **Loading States**: Show skeleton while filtering
- **No Results**: Handle empty filter results gracefully

## Performance Optimizations

### 1. Debounced Search
- Implement 300ms debounce for search input
- Cancel previous requests when new search is initiated
- Show loading indicator during search

### 2. Client-Side Filtering
- For small datasets (< 100 jobs), filter client-side after initial load
- Cache filter results to avoid redundant API calls
- Implement virtual scrolling for large result sets

### 3. URL State Synchronization
- Use `useRouter` with shallow routing for filter updates
- Prevent unnecessary page reloads
- Maintain browser history for back/forward navigation

## Data Flow Architecture

### 1. Server-Side Initial Load
```typescript
// app/jobs/page.tsx
export default async function JobsPage({ searchParams }: { searchParams: Record<string, string> }) {
  const initialFilters = urlParamsToFilters(new URLSearchParams(searchParams))
  const initialJobs = await getFilteredJobs(initialFilters)
  
  return (
    <JobsPageClient 
      initialJobs={initialJobs}
      initialFilters={initialFilters}
    />
  )
}
```

### 2. Client-Side Filter Updates
```typescript
// components/jobs-page-client.tsx
export function JobsPageClient({ initialJobs, initialFilters }: Props) {
  const [jobs, setJobs] = useState(initialJobs)
  const { filters, updateFilters } = useJobFilters(initialFilters)
  
  useEffect(() => {
    // Fetch filtered jobs when filters change
    const fetchJobs = async () => {
      const filteredJobs = await getFilteredJobs(filters)
      setJobs(filteredJobs)
    }
    
    fetchJobs()
  }, [filters])
  
  return (
    <>
      <JobFilters filters={filters} onFiltersChange={updateFilters} />
      <JobListingGrid jobs={jobs} />
    </>
  )
}
```

## Accessibility Requirements

### 1. Filter Controls
- All filter inputs must be keyboard accessible
- Proper ARIA labels for screen readers
- Focus management in dropdown menus
- Clear indication of selected filters

### 2. Results Announcement
- Announce filter result counts to screen readers
- Live region updates when filters change
- Clear messaging for empty results

### 3. Mobile Accessibility
- Touch-friendly filter controls (44px minimum tap target)
- Proper heading structure in mobile filter panel
- Clear close button for modal overlays

## Testing Strategy

### 1. Unit Tests
```typescript
// __tests__/use-job-filters.test.ts
describe('useJobFilters', () => {
  it('should update URL params when filters change', () => {
    // Test filter state synchronization
  })
  
  it('should parse initial filters from URL params', () => {
    // Test URL parameter parsing
  })
  
  it('should reset filters correctly', () => {
    // Test reset functionality
  })
})
```

### 2. Integration Tests
- Test filter component interactions
- Test database query filtering
- Test URL state management

### 3. E2E Tests
- Filter jobs by location and verify results
- Apply multiple filters and test combinations
- Test filter persistence across page refreshes
- Test mobile filter panel functionality

## Implementation Steps

### Phase 1: Core Filtering (2 days)
1. Create filter state management hook
2. Build individual filter components
3. Implement basic client-side filtering
4. Add URL parameter synchronization

### Phase 2: Database Integration (1-2 days)
1. Enhance database queries with filters
2. Implement server-side filtering
3. Add search functionality
4. Optimize query performance

### Phase 3: Polish & Mobile (1-2 days)
1. Implement responsive mobile layout
2. Add animations and transitions
3. Performance optimizations
4. Accessibility improvements
5. Comprehensive testing

## Error Handling

### 1. Filter Validation
- Validate filter values from URL parameters
- Handle malformed or invalid filter combinations
- Provide fallback to default state

### 2. Search Errors
- Handle database query failures gracefully
- Show user-friendly error messages
- Provide retry mechanisms

### 3. Empty Results
- Clear messaging when no jobs match filters
- Suggest alternative filters or search terms
- Link to post a job if no results found

## Dependencies
- Next.js App Router with searchParams
- Supabase for database queries
- React hooks for state management
- Tailwind CSS for responsive styling
- TypeScript for type safety

## Estimated Timeline
**Total**: 4-6 days
- **Phase 1**: 2 days
- **Phase 2**: 1-2 days
- **Phase 3**: 1-2 days