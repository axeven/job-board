# Step 2.4: Protected Routes Implementation Plan

## Overview
This step implements server-side authentication checks, protected route components, and enhanced navigation with proper authentication state management to secure sensitive areas of the application.

## Objectives
- Enhance server-side authentication utilities for route protection
- Create protected route wrapper components
- Implement authentication-aware navigation
- Set up user dashboard foundation with authentication checks
- Add proper loading and error states for protected content
- Ensure consistent authentication behavior across the app

## Prerequisites
- ✅ Step 2.1 completed (Auth context, utilities, and middleware)
- ✅ Step 2.2 completed (Auth components)
- ✅ Step 2.3 completed (Auth pages)
- ✅ Existing middleware handles route-level protection

## Implementation Tasks

### Task 2.4.1: Enhanced Server-Side Auth Utilities
**File**: `src/lib/auth/server.ts`
**Priority**: High
**Estimated Time**: 1 hour

```typescript
import { redirect } from 'next/navigation'
import { createClient } from '@/lib/supabase/server'
import { User } from '@supabase/supabase-js'

export interface AuthRequirement {
  redirectTo?: string
  redirectWithReturn?: boolean
}

/**
 * Server-side authentication utilities for App Router
 */
export const authServer = {
  /**
   * Get current user - returns null if not authenticated
   */
  async getUser(): Promise<User | null> {
    try {
      const supabase = await createClient()
      const { data: { user }, error } = await supabase.auth.getUser()
      
      if (error) {
        console.warn('Auth check failed:', error.message)
        return null
      }
      
      return user
    } catch (error) {
      console.error('Unexpected auth error:', error)
      return null
    }
  },

  /**
   * Get current session - returns null if not authenticated
   */
  async getSession() {
    try {
      const supabase = await createClient()
      const { data: { session }, error } = await supabase.auth.getSession()
      
      if (error) {
        console.warn('Session check failed:', error.message)
        return null
      }
      
      return session
    } catch (error) {
      console.error('Unexpected session error:', error)
      return null
    }
  },

  /**
   * Require authentication - redirects if not authenticated
   */
  async requireAuth(options: AuthRequirement = {}): Promise<User> {
    const user = await this.getUser()
    
    if (!user) {
      const redirectTo = options.redirectTo || '/auth/login'
      
      if (options.redirectWithReturn) {
        // Add current path as return URL
        const currentPath = new URL(process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000')
        currentPath.pathname = redirectTo
        currentPath.searchParams.set('redirectedFrom', '/dashboard') // This would be dynamic in real implementation
        redirect(currentPath.toString())
      } else {
        redirect(redirectTo)
      }
    }
    
    return user
  },

  /**
   * Check if user is authenticated without redirecting
   */
  async isAuthenticated(): Promise<boolean> {
    const user = await this.getUser()
    return !!user
  },

  /**
   * Require specific permissions (extensible for future roles/permissions)
   */
  async requirePermission(permission: string): Promise<User> {
    const user = await this.requireAuth()
    
    // For now, all authenticated users have all permissions
    // This can be extended with role-based access control
    if (permission === 'post_jobs' || permission === 'manage_jobs') {
      return user
    }
    
    redirect('/dashboard?error=insufficient_permissions')
  }
}
```

### Task 2.4.2: Protected Route Component
**File**: `src/components/auth/protected-route.tsx`
**Priority**: High
**Estimated Time**: 1.5 hours

```typescript
'use client'

import { useEffect, useState } from 'react'
import { useRouter, usePathname } from 'next/navigation'
import { useAuth } from '@/lib/auth/context'
import { AuthLoading } from './auth-loading'

interface ProtectedRouteProps {
  children: React.ReactNode
  fallback?: React.ReactNode
  redirectTo?: string
  requirePermission?: string
}

export function ProtectedRoute({ 
  children, 
  fallback,
  redirectTo = '/auth/login',
  requirePermission
}: ProtectedRouteProps) {
  const { user, loading } = useAuth()
  const router = useRouter()
  const pathname = usePathname()
  const [isAuthorized, setIsAuthorized] = useState(false)

  useEffect(() => {
    if (loading) return

    if (!user) {
      // Redirect to login with return URL
      const loginUrl = new URL(redirectTo, window.location.origin)
      loginUrl.searchParams.set('redirectedFrom', pathname)
      router.push(loginUrl.toString())
      return
    }

    // Check permissions if required
    if (requirePermission) {
      // For now, all authenticated users have all permissions
      // This can be extended with role-based checks
      const hasPermission = checkPermission(user, requirePermission)
      
      if (!hasPermission) {
        router.push('/dashboard?error=insufficient_permissions')
        return
      }
    }

    setIsAuthorized(true)
  }, [user, loading, router, pathname, redirectTo, requirePermission])

  // Show loading state while checking authentication
  if (loading || (!isAuthorized && user)) {
    return fallback || <AuthLoading />
  }

  // Don't render content if not authenticated/authorized
  if (!user || !isAuthorized) {
    return fallback || <AuthLoading />
  }

  return <>{children}</>
}

/**
 * Higher-order component for protecting pages
 */
export function withAuth<T extends object>(
  Component: React.ComponentType<T>,
  options: Omit<ProtectedRouteProps, 'children'> = {}
) {
  return function AuthenticatedComponent(props: T) {
    return (
      <ProtectedRoute {...options}>
        <Component {...props} />
      </ProtectedRoute>
    )
  }
}

/**
 * Check if user has specific permission
 */
function checkPermission(user: any, permission: string): boolean {
  // Basic permission checking - can be extended
  switch (permission) {
    case 'post_jobs':
    case 'manage_jobs':
      return !!user // All authenticated users can post/manage jobs
    default:
      return false
  }
}
```

### Task 2.4.3: Server Component Protection Wrapper
**File**: `src/components/auth/server-protected.tsx`
**Priority**: High
**Estimated Time**: 45 minutes

```typescript
import { redirect } from 'next/navigation'
import { authServer } from '@/lib/auth/server'

interface ServerProtectedProps {
  children: React.ReactNode
  fallback?: React.ReactNode
  redirectTo?: string
  requirePermission?: string
}

/**
 * Server-side protected route component
 * Use this for server components that need authentication
 */
export async function ServerProtected({ 
  children, 
  redirectTo = '/auth/login',
  requirePermission
}: ServerProtectedProps) {
  // Check authentication on server side
  const user = await authServer.getUser()

  if (!user) {
    redirect(redirectTo)
  }

  // Check permissions if required
  if (requirePermission) {
    await authServer.requirePermission(requirePermission)
  }

  return <>{children}</>
}

/**
 * Page-level authentication wrapper
 * Use this to wrap entire page components
 */
export function createProtectedPage<T extends object>(
  PageComponent: React.ComponentType<T>,
  options: {
    redirectTo?: string
    requirePermission?: string
  } = {}
) {
  return async function ProtectedPage(props: T) {
    // Server-side auth check
    await authServer.requireAuth({
      redirectTo: options.redirectTo,
      redirectWithReturn: true
    })

    // Check permissions if required
    if (options.requirePermission) {
      await authServer.requirePermission(options.requirePermission)
    }

    return <PageComponent {...props} />
  }
}
```

### Task 2.4.4: Authentication-Aware Navigation
**File**: `src/components/layout/navbar.tsx`
**Priority**: High
**Estimated Time**: 1.5 hours

```typescript
'use client'

import Link from 'next/link'
import { useAuth } from '@/lib/auth/context'
import { AuthButton } from '@/components/auth/auth-button'
import { Button } from '@/components/ui/button'

export function Navbar() {
  const { user, loading } = useAuth()

  return (
    <nav className="bg-white shadow-sm border-b border-gray-200">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between h-16">
          {/* Logo and primary navigation */}
          <div className="flex items-center">
            <Link href="/" className="flex items-center">
              <h1 className="text-xl font-bold text-gray-900">Job Board</h1>
            </Link>
            
            <div className="hidden sm:ml-8 sm:flex sm:space-x-8">
              <Link
                href="/jobs"
                className="text-gray-700 hover:text-gray-900 px-3 py-2 text-sm font-medium"
              >
                Browse Jobs
              </Link>
              
              {user && (
                <>
                  <Link
                    href="/post-job"
                    className="text-gray-700 hover:text-gray-900 px-3 py-2 text-sm font-medium"
                  >
                    Post a Job
                  </Link>
                  <Link
                    href="/dashboard"
                    className="text-gray-700 hover:text-gray-900 px-3 py-2 text-sm font-medium"
                  >
                    Dashboard
                  </Link>
                </>
              )}
            </div>
          </div>

          {/* Auth section */}
          <div className="flex items-center space-x-4">
            {!loading && !user && (
              <Button
                as={Link}
                href="/post-job"
                variant="primary"
                size="sm"
                className="hidden sm:inline-flex"
              >
                Post a Job
              </Button>
            )}
            
            <AuthButton size="sm" showProfile={false} />
          </div>

          {/* Mobile menu button */}
          <div className="sm:hidden flex items-center">
            <button
              type="button"
              className="text-gray-400 hover:text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-blue-500 p-2 rounded-md"
              aria-label="Open main menu"
            >
              <svg className="block h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
              </svg>
            </button>
          </div>
        </div>
      </div>

      {/* Mobile menu */}
      <MobileMenu />
    </nav>
  )
}

function MobileMenu() {
  const { user } = useAuth()
  // This would typically use a toggle state - simplified for brevity

  return (
    <div className="sm:hidden border-t border-gray-200">
      <div className="px-2 py-3 space-y-1">
        <Link
          href="/jobs"
          className="block px-3 py-2 text-base font-medium text-gray-700 hover:text-gray-900 hover:bg-gray-50 rounded-md"
        >
          Browse Jobs
        </Link>
        
        {user && (
          <>
            <Link
              href="/post-job"
              className="block px-3 py-2 text-base font-medium text-gray-700 hover:text-gray-900 hover:bg-gray-50 rounded-md"
            >
              Post a Job
            </Link>
            <Link
              href="/dashboard"
              className="block px-3 py-2 text-base font-medium text-gray-700 hover:text-gray-900 hover:bg-gray-50 rounded-md"
            >
              Dashboard
            </Link>
          </>
        )}
      </div>
    </div>
  )
}
```

### Task 2.4.5: Dashboard Foundation
**File**: `src/app/dashboard/layout.tsx`
**Priority**: High
**Estimated Time**: 1 hour

```typescript
import { Metadata } from 'next'
import { authServer } from '@/lib/auth/server'
import { DashboardSidebar } from '@/components/dashboard/sidebar'
import { DashboardHeader } from '@/components/dashboard/header'

export const metadata: Metadata = {
  title: 'Dashboard - Job Board',
  description: 'Manage your job postings and account settings',
}

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  // Server-side authentication check
  const user = await authServer.requireAuth({
    redirectTo: '/auth/login',
    redirectWithReturn: true
  })

  return (
    <div className="min-h-screen bg-gray-50">
      <DashboardHeader user={user} />
      
      <div className="flex">
        <DashboardSidebar />
        
        <main className="flex-1 p-6">
          <div className="max-w-7xl mx-auto">
            {children}
          </div>
        </main>
      </div>
    </div>
  )
}
```

**File**: `src/components/dashboard/header.tsx`
**Priority**: Medium
**Estimated Time**: 45 minutes

```typescript
import { User } from '@supabase/supabase-js'
import { AuthButton } from '@/components/auth/auth-button'

interface DashboardHeaderProps {
  user: User
}

export function DashboardHeader({ user }: DashboardHeaderProps) {
  return (
    <header className="bg-white shadow-sm border-b border-gray-200">
      <div className="max-w-7xl mx-auto px-6 py-4">
        <div className="flex justify-between items-center">
          <div>
            <h1 className="text-2xl font-bold text-gray-900">Dashboard</h1>
            <p className="text-sm text-gray-600">Welcome back, {user.email}</p>
          </div>
          
          <AuthButton variant="outline" size="sm" />
        </div>
      </div>
    </header>
  )
}
```

**File**: `src/components/dashboard/sidebar.tsx`
**Priority**: Medium
**Estimated Time**: 45 minutes

```typescript
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { clsx } from 'clsx'

const navigation = [
  { name: 'Overview', href: '/dashboard', icon: HomeIcon },
  { name: 'My Jobs', href: '/dashboard/jobs', icon: BriefcaseIcon },
  { name: 'Post New Job', href: '/post-job', icon: PlusIcon },
  { name: 'Profile', href: '/dashboard/profile', icon: UserIcon },
]

export function DashboardSidebar() {
  const pathname = usePathname()

  return (
    <aside className="w-64 bg-white shadow-sm border-r border-gray-200 min-h-screen">
      <nav className="p-6">
        <ul className="space-y-2">
          {navigation.map((item) => {
            const isActive = pathname === item.href
            
            return (
              <li key={item.name}>
                <Link
                  href={item.href}
                  className={clsx(
                    'flex items-center px-3 py-2 text-sm font-medium rounded-md transition-colors',
                    isActive
                      ? 'bg-blue-50 text-blue-700 border-r-2 border-blue-700'
                      : 'text-gray-700 hover:bg-gray-50 hover:text-gray-900'
                  )}
                >
                  <item.icon className="mr-3 h-5 w-5" />
                  {item.name}
                </Link>
              </li>
            )
          })}
        </ul>
      </nav>
    </aside>
  )
}

// Icon components (using heroicons or similar)
function HomeIcon({ className }: { className?: string }) {
  return (
    <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
    </svg>
  )
}

function BriefcaseIcon({ className }: { className?: string }) {
  return (
    <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 13.255A23.931 23.931 0 0112 15c-3.183 0-6.22-.62-9-1.745M16 6V4a2 2 0 00-2-2h-4a2 2 0 00-2-2v2m8 0H8m8 0v2H8V6" />
    </svg>
  )
}

function PlusIcon({ className }: { className?: string }) {
  return (
    <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
    </svg>
  )
}

function UserIcon({ className }: { className?: string }) {
  return (
    <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
    </svg>
  )
}
```

### Task 2.4.6: Dashboard Home Page
**File**: `src/app/dashboard/page.tsx`
**Priority**: Medium
**Estimated Time**: 1 hour

```typescript
import { authServer } from '@/lib/auth/server'
import { jobsServer } from '@/lib/database/jobs'
import { DashboardStats } from '@/components/dashboard/stats'
import { RecentJobs } from '@/components/dashboard/recent-jobs'

export default async function DashboardPage() {
  const user = await authServer.requireAuth()
  
  // Fetch user's jobs for stats
  const { data: userJobs = [], error } = await jobsServer.getByUser(user.id)
  
  if (error) {
    console.error('Failed to fetch user jobs:', error)
  }

  const stats = {
    totalJobs: userJobs.length,
    activeJobs: userJobs.filter(job => !job.is_archived).length,
    // Add more stats as needed
  }

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-2xl font-bold text-gray-900">Overview</h2>
        <p className="mt-1 text-sm text-gray-600">
          Welcome to your dashboard. Here's what's happening with your job postings.
        </p>
      </div>

      <DashboardStats stats={stats} />
      
      <RecentJobs jobs={userJobs.slice(0, 5)} />
    </div>
  )
}
```

### Task 2.4.7: Environment Configuration Update
**File**: `.env.development` (update existing)
**Priority**: Low
**Estimated Time**: 15 minutes

```bash
# Add site URL for auth redirects
NEXT_PUBLIC_SITE_URL=http://localhost:3000
```

## Testing Strategy

### Unit Tests
**File**: `src/lib/auth/__tests__/server.test.ts`
- Server-side auth utilities
- Permission checking
- Error handling

**File**: `src/components/auth/__tests__/protected-route.test.tsx`
- Client-side route protection
- Loading states
- Redirect behavior

### Integration Tests
**File**: `__tests__/protected-pages.test.tsx`
- Dashboard access with/without auth
- Proper redirects for unauthenticated users
- Navigation state changes

## Verification Steps

1. **Protected Route Access**:
   ```bash
   npm run dev
   # Try accessing /dashboard without authentication
   # Verify redirect to login page
   ```

2. **Authentication Flow**:
   - Login and access dashboard
   - Verify navigation shows correct state
   - Test logout and verify redirect

3. **Server-Side Protection**:
   - Check direct API calls to protected endpoints
   - Verify server-side redirects work correctly

## Security Considerations

1. **Server-Side Validation**: All protected pages/APIs verify authentication server-side
2. **Client-Side UX**: Client components provide immediate feedback while maintaining security
3. **Permission System**: Extensible system for future role-based access control
4. **Secure Redirects**: Prevent open redirect vulnerabilities in auth flows

## Performance Considerations

1. **Server-Side Checks**: Minimal database calls for auth verification
2. **Client-Side Caching**: Auth context prevents unnecessary re-renders
3. **Code Splitting**: Protected components loaded only when needed
4. **Optimistic UI**: Immediate feedback while server validation occurs

## Success Criteria
- [ ] Dashboard requires authentication and redirects properly
- [ ] Protected routes work on both server and client side  
- [ ] Navigation shows correct state based on authentication
- [ ] Server-side auth utilities prevent unauthorized access
- [ ] Loading states provide good UX during auth checks
- [ ] All error scenarios are handled gracefully
- [ ] Permission system is extensible for future features

## Dependencies for Next Steps
This step provides protected route infrastructure for:
- **Phase 3**: Job management features will use route protection
- **Phase 4**: Full dashboard functionality will build on this foundation
- All future authenticated features will use these patterns