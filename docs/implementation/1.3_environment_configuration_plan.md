# 1.3 Environment Configuration Implementation Plan

## Overview
This document outlines the implementation plan for configuring the Next.js application to work with Supabase, including environment variables, client setup, and TypeScript integration.

## Environment Setup Requirements

### Environment Variables Needed
- `NEXT_PUBLIC_SUPABASE_URL` - Supabase project URL (public)
- `NEXT_PUBLIC_SUPABASE_ANON_KEY` - Supabase anonymous key (public)
- `SUPABASE_SERVICE_ROLE_KEY` - Server-side operations key (private, optional)

## Implementation Steps

### Step 1: Create Environment Files
1. Create `.env.local` file in project root
2. Add `.env.local` to `.gitignore` (should already be there)
3. Create `.env.example` for documentation

**File: `.env.local`**
```bash
# Supabase Configuration
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
```

**File: `.env.example`**
```bash
# Supabase Configuration
# Get these values from your Supabase project settings
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
```

### Step 2: Create Supabase Client Configuration
1. Create `lib` directory structure
2. Set up browser client for client-side operations
3. Set up server client for server-side operations

**File: `lib/supabase/client.ts`**
```typescript
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'
import { Database } from '@/types/supabase'

export const createClient = () => {
  return createClientComponentClient<Database>()
}

// For use in Client Components
export const supabase = createClient()
```

**File: `lib/supabase/server.ts`**
```typescript
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs'
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { Database } from '@/types/supabase'

// For use in Server Components
export const createServerClient = () => {
  return createServerComponentClient<Database>({ cookies })
}

// For use in Route Handlers (API routes)
export const createRouteHandlerClientClient = () => {
  return createRouteHandlerClient<Database>({ cookies })
}

// For use in Server Actions
export const createServerActionClient = () => {
  return createServerComponentClient<Database>({ 
    cookies: () => cookies() 
  })
}
```

### Step 3: Install Required Dependencies
1. Install Supabase auth helpers for Next.js
2. Update existing Supabase client if needed

**Commands:**
```bash
npm install @supabase/auth-helpers-nextjs
npm install @supabase/auth-helpers-react
```

### Step 4: Create TypeScript Configuration
1. Generate TypeScript types from Supabase
2. Create helper types for the application
3. Set up proper type exports

**File: `types/supabase.ts`** (Generated)
```typescript
// This file will be generated using:
// npx supabase gen types typescript --project-id YOUR_PROJECT_ID
export type Database = {
  // Generated types will go here
}
```

**File: `types/database.ts`**
```typescript
import { Database } from './supabase'

// Job-related types
export type Job = Database['public']['Tables']['jobs']['Row']
export type JobInsert = Database['public']['Tables']['jobs']['Insert']
export type JobUpdate = Database['public']['Tables']['jobs']['Update']
export type JobType = Database['public']['Enums']['job_type_enum']

// Auth types
export type User = Database['auth']['Tables']['users']['Row']

// API response types
export type JobsResponse = {
  data: Job[] | null
  error: string | null
}

export type JobResponse = {
  data: Job | null
  error: string | null
}
```

### Step 5: Create Database Helper Functions
1. Create CRUD operations for jobs
2. Add error handling and type safety
3. Include filters and sorting

**File: `lib/database/jobs.ts`**
```typescript
import { createClient } from '@/lib/supabase/client'
import { createServerClient } from '@/lib/supabase/server'
import type { Job, JobInsert, JobUpdate, JobType } from '@/types/database'

// Client-side operations
export const jobsClient = {
  // Get all jobs with optional filters
  async getAll(filters?: {
    job_type?: JobType
    location?: string
    search?: string
  }) {
    const supabase = createClient()
    let query = supabase
      .from('jobs')
      .select('*')
      .order('created_at', { ascending: false })

    if (filters?.job_type) {
      query = query.eq('job_type', filters.job_type)
    }

    if (filters?.location) {
      query = query.ilike('location', `%${filters.location}%`)
    }

    if (filters?.search) {
      query = query.or(`title.ilike.%${filters.search}%,company.ilike.%${filters.search}%,description.ilike.%${filters.search}%`)
    }

    return query
  },

  // Get single job by ID
  async getById(id: string) {
    const supabase = createClient()
    return supabase
      .from('jobs')
      .select('*')
      .eq('id', id)
      .single()
  },

  // Create new job
  async create(job: JobInsert) {
    const supabase = createClient()
    return supabase
      .from('jobs')
      .insert(job)
      .select()
      .single()
  },

  // Update existing job
  async update(id: string, job: JobUpdate) {
    const supabase = createClient()
    return supabase
      .from('jobs')
      .update(job)
      .eq('id', id)
      .select()
      .single()
  },

  // Delete job
  async delete(id: string) {
    const supabase = createClient()
    return supabase
      .from('jobs')
      .delete()
      .eq('id', id)
  },

  // Get user's jobs
  async getByUser(userId: string) {
    const supabase = createClient()
    return supabase
      .from('jobs')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
  }
}

// Server-side operations (for Server Components)
export const jobsServer = {
  // Similar functions but using createServerClient()
  async getAll(filters?: {
    job_type?: JobType
    location?: string
    search?: string
  }) {
    const supabase = createServerClient()
    // Same implementation as client version
  },

  async getById(id: string) {
    const supabase = createServerClient()
    return supabase
      .from('jobs')
      .select('*')
      .eq('id', id)
      .single()
  }
}
```

### Step 6: Create Environment Validation
1. Validate required environment variables
2. Provide clear error messages
3. Type-safe environment variable access

**File: `lib/env.ts`**
```typescript
function getEnvVar(name: string, fallback?: string): string {
  const value = process.env[name] ?? fallback
  
  if (!value) {
    throw new Error(`Missing required environment variable: ${name}`)
  }
  
  return value
}

export const env = {
  SUPABASE_URL: getEnvVar('NEXT_PUBLIC_SUPABASE_URL'),
  SUPABASE_ANON_KEY: getEnvVar('NEXT_PUBLIC_SUPABASE_ANON_KEY'),
  SUPABASE_SERVICE_ROLE_KEY: getEnvVar('SUPABASE_SERVICE_ROLE_KEY', ''),
} as const

// Validate environment on startup
export function validateEnv() {
  try {
    env.SUPABASE_URL
    env.SUPABASE_ANON_KEY
    console.log('✅ Environment variables validated')
  } catch (error) {
    console.error('❌ Environment validation failed:', error)
    throw error
  }
}
```

### Step 7: Update Next.js Configuration
1. Add environment validation to Next.js config
2. Configure any necessary middleware

**File: `next.config.ts`** (Update existing)
```typescript
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  experimental: {
    serverActions: true,
  },
  env: {
    // Explicitly expose environment variables if needed
    CUSTOM_KEY: process.env.CUSTOM_KEY,
  }
};

export default nextConfig;
```

### Step 8: Create Middleware for Auth
1. Set up middleware to handle auth state
2. Configure protected routes

**File: `middleware.ts`**
```typescript
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import type { Database } from '@/types/supabase'

export async function middleware(req: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient<Database>({ req, res })

  // Refresh session if expired
  const {
    data: { session },
  } = await supabase.auth.getSession()

  // Protected routes that require authentication
  const protectedRoutes = ['/dashboard', '/post-job']
  const isProtectedRoute = protectedRoutes.some(route => 
    req.nextUrl.pathname.startsWith(route)
  )

  if (isProtectedRoute && !session) {
    // Redirect to login if accessing protected route without auth
    const redirectUrl = req.nextUrl.clone()
    redirectUrl.pathname = '/auth/login'
    redirectUrl.searchParams.set('redirectedFrom', req.nextUrl.pathname)
    return NextResponse.redirect(redirectUrl)
  }

  return res
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
}
```

## Testing Configuration

### Step 9: Test Environment Setup
1. Verify environment variables are loaded
2. Test Supabase client connections
3. Validate TypeScript types

**File: `lib/test-setup.ts`** (Development only)
```typescript
import { supabase } from '@/lib/supabase/client'
import { validateEnv } from '@/lib/env'

export async function testSupabaseConnection() {
  try {
    // Validate environment
    validateEnv()
    console.log('✅ Environment variables loaded')

    // Test connection
    const { data, error } = await supabase.from('jobs').select('count')
    
    if (error) {
      console.error('❌ Supabase connection failed:', error)
      return false
    }
    
    console.log('✅ Supabase connection successful')
    return true
  } catch (error) {
    console.error('❌ Setup test failed:', error)
    return false
  }
}
```

### Step 10: Create Development Scripts
1. Add helpful npm scripts
2. Create database reset/seed scripts

**Update `package.json`:**
```json
{
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build --turbopack",
    "start": "next start",
    "lint": "eslint",
    "type-check": "tsc --noEmit",
    "test-db": "node -e \"require('./lib/test-setup').testSupabaseConnection()\"",
    "generate-types": "npx supabase gen types typescript --project-id $PROJECT_ID > types/supabase.ts"
  }
}
```

## Documentation

### Step 11: Update README with Setup Instructions
1. Document environment variable setup
2. Add troubleshooting section

**Update README.md section:**
```markdown
## Environment Setup

1. Copy the example environment file:
```bash
cp .env.example .env.local
```

2. Fill in your Supabase credentials from your project dashboard:
   - Go to Project Settings > API
   - Copy Project URL and anon public key
   - Paste into `.env.local`

3. Test your configuration:
```bash
npm run test-db
```
```

## Success Criteria
- [ ] Environment variables configured correctly
- [ ] Supabase client setup for browser and server
- [ ] TypeScript types generated and configured
- [ ] Database helper functions created
- [ ] Environment validation implemented
- [ ] Middleware configured for auth protection
- [ ] Development scripts added
- [ ] Connection tested successfully
- [ ] Documentation updated

## Troubleshooting

### Common Issues
1. **"Invalid API key"** - Check environment variables are set correctly
2. **"Connection refused"** - Verify Supabase URL is correct
3. **TypeScript errors** - Regenerate types with correct project ID
4. **Middleware issues** - Check protected routes configuration

### Debug Commands
```bash
# Test environment loading
npm run test-db

# Check TypeScript compilation
npm run type-check

# Verify Supabase connection
node -e "console.log(process.env.NEXT_PUBLIC_SUPABASE_URL)"
```

## Next Steps
After completing environment configuration:
1. Begin Phase 2: Authentication System
2. Create auth components and pages
3. Implement user registration and login flows