# Step 2.1: Basic Auth Setup Implementation Plan

## Overview
This step establishes the foundational authentication infrastructure using Supabase Auth, including middleware configuration, callback handling, and global auth state management.

## Objectives
- Configure authentication middleware for route protection
- Set up OAuth callback handling for external providers
- Create auth context for global user state management
- Establish auth utility functions and types

## Prerequisites
- ✅ Phase 1 completed (Database schema, RLS policies, Environment setup)
- ✅ Supabase project configured with authentication enabled
- ✅ Environment variables properly set up

## Implementation Tasks

### Task 2.1.1: Enhanced Authentication Middleware
**File**: `middleware.ts`
**Status**: ✅ Already implemented with comprehensive route protection

Current middleware includes:
- Protected routes: `/dashboard/*`, `/post-job`
- Public routes: `/`, `/jobs/*`, `/auth/*`
- Redirect logic with `redirectedFrom` parameter
- Proper cookie handling for SSR compatibility

**Verification**: Middleware is already implemented and tested with 100% coverage.

### Task 2.1.2: Auth Callback Handler
**File**: `src/app/auth/callback/route.ts`
**Priority**: High
**Estimated Time**: 1 hour

```typescript
// API route to handle OAuth callbacks and email confirmations
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

export async function GET(request: NextRequest) {
  const requestUrl = new URL(request.url)
  const code = requestUrl.searchParams.get('code')
  const next = requestUrl.searchParams.get('next') ?? '/dashboard'

  if (code) {
    const supabase = await createClient()
    const { error } = await supabase.auth.exchangeCodeForSession(code)
    
    if (!error) {
      // Successful authentication, redirect to intended page
      return NextResponse.redirect(new URL(next, request.url))
    }
  }

  // Authentication failed, redirect to login with error
  const redirectUrl = new URL('/auth/login', request.url)
  redirectUrl.searchParams.set('error', 'Authentication failed')
  return NextResponse.redirect(redirectUrl)
}
```

### Task 2.1.3: Auth Context Provider
**File**: `src/lib/auth/context.tsx`
**Priority**: High
**Estimated Time**: 2 hours

```typescript
'use client'

import { createContext, useContext, useEffect, useState } from 'react'
import { User, Session } from '@supabase/supabase-js'
import { supabase } from '@/lib/supabase/client'

interface AuthContextType {
  user: User | null
  session: Session | null
  loading: boolean
  signOut: () => Promise<void>
  refreshSession: () => Promise<void>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [session, setSession] = useState<Session | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // Get initial session
    const getInitialSession = async () => {
      const { data: { session }, error } = await supabase().auth.getSession()
      
      if (!error) {
        setSession(session)
        setUser(session?.user ?? null)
      }
      
      setLoading(false)
    }

    getInitialSession()

    // Listen for auth changes
    const { data: { subscription } } = supabase().auth.onAuthStateChange(
      async (event, session) => {
        setSession(session)
        setUser(session?.user ?? null)
        setLoading(false)
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  const signOut = async () => {
    setLoading(true)
    await supabase().auth.signOut()
    // State will be updated via onAuthStateChange
  }

  const refreshSession = async () => {
    const { data: { session } } = await supabase().auth.refreshSession()
    setSession(session)
    setUser(session?.user ?? null)
  }

  return (
    <AuthContext.Provider value={{
      user,
      session,
      loading,
      signOut,
      refreshSession
    }}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}
```

### Task 2.1.4: Auth Utilities and Types
**File**: `src/lib/auth/types.ts`
**Priority**: Medium
**Estimated Time**: 30 minutes

```typescript
import { User } from '@supabase/supabase-js'

export interface AuthUser extends User {
  // Extended user properties if needed
}

export interface AuthError {
  message: string
  status?: number
}

export interface AuthState {
  user: AuthUser | null
  loading: boolean
  error: AuthError | null
}

export type AuthAction = 
  | 'SIGN_IN'
  | 'SIGN_UP' 
  | 'SIGN_OUT'
  | 'PASSWORD_RESET'
  | 'EMAIL_VERIFICATION'
```

**File**: `src/lib/auth/utils.ts`
**Priority**: Medium
**Estimated Time**: 1 hour

```typescript
import { supabase } from '@/lib/supabase/client'
import { createClient } from '@/lib/supabase/server'
import { AuthError } from './types'

// Client-side auth utilities
export const authClient = {
  async signIn(email: string, password: string) {
    const { data, error } = await supabase().auth.signInWithPassword({
      email,
      password
    })
    
    if (error) {
      throw new AuthError(error.message)
    }
    
    return data
  },

  async signUp(email: string, password: string) {
    const { data, error } = await supabase().auth.signUp({
      email,
      password,
      options: {
        emailRedirectTo: `${window.location.origin}/auth/callback`
      }
    })
    
    if (error) {
      throw new AuthError(error.message)
    }
    
    return data
  },

  async signOut() {
    const { error } = await supabase().auth.signOut()
    
    if (error) {
      throw new AuthError(error.message)
    }
  },

  async resetPassword(email: string) {
    const { error } = await supabase().auth.resetPasswordForEmail(email, {
      redirectTo: `${window.location.origin}/auth/callback?next=/auth/reset-password`
    })
    
    if (error) {
      throw new AuthError(error.message)
    }
  }
}

// Server-side auth utilities
export const authServer = {
  async getUser() {
    const supabase = await createClient()
    const { data: { user }, error } = await supabase.auth.getUser()
    
    if (error) {
      return null
    }
    
    return user
  },

  async getSession() {
    const supabase = await createClient()
    const { data: { session }, error } = await supabase.auth.getSession()
    
    if (error) {
      return null
    }
    
    return session
  },

  async requireAuth() {
    const user = await this.getUser()
    
    if (!user) {
      throw new Error('Authentication required')
    }
    
    return user
  }
}

class AuthError extends Error {
  constructor(message: string, public status?: number) {
    super(message)
    this.name = 'AuthError'
  }
}
```

### Task 2.1.5: Update Root Layout with Auth Provider
**File**: `src/app/layout.tsx`
**Priority**: High
**Estimated Time**: 30 minutes

```typescript
import { AuthProvider } from '@/lib/auth/context'
// ... other imports

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" className={`${GeistSans.variable} ${GeistMono.variable}`}>
      <body className="font-sans antialiased">
        <AuthProvider>
          {children}
        </AuthProvider>
      </body>
    </html>
  )
}
```

### Task 2.1.6: Auth Configuration
**File**: `src/lib/auth/config.ts`
**Priority**: Low
**Estimated Time**: 30 minutes

```typescript
export const authConfig = {
  // Redirect paths
  redirects: {
    login: '/auth/login',
    signup: '/auth/signup',
    dashboard: '/dashboard',
    afterLogin: '/dashboard',
    afterSignup: '/auth/verify-email'
  },

  // Protected route patterns
  protectedRoutes: [
    '/dashboard',
    '/post-job'
  ],

  // Public routes that don't require auth
  publicRoutes: [
    '/',
    '/jobs',
    '/auth'
  ],

  // OAuth providers (for future enhancement)
  providers: {
    google: {
      enabled: false,
      scopes: 'email profile'
    },
    github: {
      enabled: false,
      scopes: 'user:email'
    }
  }
}
```

## Testing Strategy

### Unit Tests
**File**: `src/lib/auth/__tests__/context.test.tsx`
- Auth context provider functionality
- Hook usage and error handling
- State management during auth changes

**File**: `src/lib/auth/__tests__/utils.test.ts`
- Auth utility functions
- Error handling for failed authentication
- Server-side auth validation

**File**: `__tests__/auth-callback.test.ts`
- OAuth callback handling
- Code exchange for session
- Error scenarios and redirects

### Integration Tests
- End-to-end authentication flow
- Protected route access verification
- Session persistence across page reloads

## Verification Steps

1. **Auth Context Setup**:
   ```bash
   # Verify context provider is working
   npm run dev
   # Check browser dev tools for auth state
   ```

2. **Middleware Verification**: ✅ Already completed and tested

3. **Callback Handler Test**:
   ```bash
   # Test callback route exists
   curl http://localhost:3000/auth/callback?code=test
   ```

4. **Type Safety**:
   ```bash
   npm run lint
   npx tsc --noEmit
   ```

## Dependencies
- ✅ `@supabase/ssr` - Already installed
- ✅ `@supabase/supabase-js` - Already installed
- React 18+ context and hooks

## Security Considerations
- ✅ Secure cookie configuration in middleware
- ✅ CSRF protection via Supabase's built-in mechanisms  
- ✅ Proper session validation on server-side
- Input validation for auth forms (handled in Step 2.2)
- Rate limiting for auth endpoints (Supabase handles this)

## Performance Considerations
- Lazy loading of auth context
- Minimal re-renders during auth state changes
- Efficient session refresh mechanism
- Client-side caching of user data

## Error Scenarios
1. **Invalid authentication credentials**
2. **Network failures during auth**
3. **Session expiration**
4. **OAuth provider errors**
5. **Email verification required**

## Success Criteria
- [ ] Auth context provides user state globally
- [ ] OAuth callback handler works correctly  
- [ ] Server-side auth utilities function properly
- [ ] Protected routes redirect unauthenticated users
- [ ] Auth state persists across page reloads
- [ ] Error handling works for all auth scenarios

## Dependencies for Next Steps
This step provides the foundation for:
- **Step 2.2**: Authentication components will use the auth context
- **Step 2.3**: Auth pages will use the auth utilities
- **Step 2.4**: Protected routes will use server-side auth validation