# 1.2 Row Level Security (RLS) Implementation Plan

## Overview
This document outlines the implementation plan for setting up Row Level Security policies on the jobs table to ensure proper data access control and security.

## RLS Requirements

### Security Goals
1. **Public Read Access**: Anyone can view all job postings
2. **Authenticated Write Access**: Only authenticated users can create jobs
3. **Owner-Only Modification**: Users can only edit/delete their own job postings
4. **Restrict Deletion**: Users cannot be deleted if they have associated jobs - jobs must be deleted first to maintain data integrity

## Implementation Steps

### Step 1: Enable RLS on Jobs Table
1. Navigate to Supabase SQL Editor
2. Enable Row Level Security on the jobs table
3. Verify RLS is enabled in the dashboard

**SQL Command:**
```sql
ALTER TABLE jobs ENABLE ROW LEVEL SECURITY;
```

### Step 2: Create Public Read Policy
Allow all users (authenticated and anonymous) to read job postings.

**Policy Name:** `jobs_select_policy`
**SQL Command:**
```sql
CREATE POLICY "jobs_select_policy" ON jobs
    FOR SELECT
    USING (true);
```

**Explanation:**
- `FOR SELECT` - Applies to read operations
- `USING (true)` - Always allows read access (public)

### Step 3: Create Authenticated Insert Policy
Allow only authenticated users to create new job postings.

**Policy Name:** `jobs_insert_policy`
**SQL Command:**
```sql
CREATE POLICY "jobs_insert_policy" ON jobs
    FOR INSERT
    WITH CHECK (auth.uid() IS NOT NULL);
```

**Explanation:**
- `FOR INSERT` - Applies to create operations
- `WITH CHECK (auth.uid() IS NOT NULL)` - Ensures user is authenticated
- `auth.uid()` - Supabase function returning current user's UUID

### Step 4: Create Owner-Only Update Policy
Allow users to update only their own job postings.

**Policy Name:** `jobs_update_policy`
**SQL Command:**
```sql
CREATE POLICY "jobs_update_policy" ON jobs
    FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());
```

**Explanation:**
- `FOR UPDATE` - Applies to modification operations
- `USING (user_id = auth.uid())` - Checks ownership before allowing update
- `WITH CHECK (user_id = auth.uid())` - Ensures user_id cannot be changed to another user

### Step 5: Create Owner-Only Delete Policy
Allow users to delete only their own job postings.

**Policy Name:** `jobs_delete_policy`
**SQL Command:**
```sql
CREATE POLICY "jobs_delete_policy" ON jobs
    FOR DELETE
    USING (user_id = auth.uid());
```

**Explanation:**
- `FOR DELETE` - Applies to delete operations
- `USING (user_id = auth.uid())` - Checks ownership before allowing deletion

### Step 6: Create Comprehensive RLS Policy (Alternative Approach)
Instead of separate policies, you can create a single comprehensive policy.

**Policy Name:** `jobs_comprehensive_policy`
**SQL Command:**
```sql
-- Drop individual policies if using comprehensive approach
-- DROP POLICY IF EXISTS "jobs_select_policy" ON jobs;
-- DROP POLICY IF EXISTS "jobs_insert_policy" ON jobs;
-- DROP POLICY IF EXISTS "jobs_update_policy" ON jobs;
-- DROP POLICY IF EXISTS "jobs_delete_policy" ON jobs;

CREATE POLICY "jobs_comprehensive_policy" ON jobs
    FOR ALL
    USING (
        -- Allow read access to everyone
        (CURRENT_USER = 'anon') OR
        -- Allow all operations for authenticated users on their own jobs
        (auth.uid() IS NOT NULL AND (user_id = auth.uid() OR CURRENT_USER = 'authenticated'))
    )
    WITH CHECK (
        -- For inserts and updates, ensure user is authenticated
        auth.uid() IS NOT NULL AND user_id = auth.uid()
    );
```

## Testing RLS Policies

### Step 7: Test Public Read Access
1. Test anonymous access to job listings
2. Verify all jobs are visible to unauthenticated users

**Test Query (as anonymous user):**
```sql
SELECT * FROM jobs;
```

### Step 8: Test Authenticated User Operations
1. Test job creation by authenticated user
2. Test updating own job
3. Test deleting own job
4. Test attempting to modify another user's job (should fail)

**Test Queries (as authenticated user):**
```sql
-- Should succeed - creating own job
INSERT INTO jobs (title, company, description, location, job_type, user_id) 
VALUES ('Test Job', 'Test Company', 'Test Description', 'Test Location', 'Full-Time', auth.uid());

-- Should succeed - updating own job
UPDATE jobs SET title = 'Updated Title' WHERE user_id = auth.uid();

-- Should fail - updating another user's job
UPDATE jobs SET title = 'Hacked Title' WHERE user_id != auth.uid();

-- Should succeed - deleting own job
DELETE FROM jobs WHERE user_id = auth.uid();
```

### Step 9: Test Edge Cases
1. Test with NULL user_id (should be prevented by foreign key)
2. Test user deletion cascade behavior
3. Test policy performance with large datasets

## Policy Optimization

### Step 10: Add Indexes for RLS Performance
RLS policies use WHERE clauses that can benefit from indexes.

**SQL Commands:**
```sql
-- Index on user_id for ownership checks (if not already created)
CREATE INDEX IF NOT EXISTS idx_jobs_user_id ON jobs(user_id);

-- Composite index for authenticated user queries
CREATE INDEX IF NOT EXISTS idx_jobs_user_created ON jobs(user_id, created_at DESC);
```

### Step 11: Monitor Policy Performance
1. Use Supabase performance insights
2. Check query execution plans
3. Monitor slow query logs

**Performance Check Query:**
```sql
EXPLAIN (ANALYZE, BUFFERS) 
SELECT * FROM jobs WHERE user_id = 'some-uuid';
```

## Security Validation

### Step 12: Security Audit Checklist
- [ ] RLS enabled on jobs table
- [ ] Public read access working
- [ ] Anonymous users cannot insert/update/delete
- [ ] Authenticated users can only modify their own jobs
- [ ] user_id cannot be spoofed in updates
- [ ] Policies are efficient and indexed
- [ ] No SQL injection vulnerabilities

### Step 13: Penetration Testing
1. Test with different user contexts
2. Attempt privilege escalation
3. Test boundary conditions
4. Verify error messages don't leak information

## Documentation

### Step 14: Document RLS Policies
Create documentation for the development team explaining:
- Which operations require authentication
- How ownership is determined
- How to test RLS policies locally
- Common troubleshooting scenarios

## Success Criteria
- [ ] RLS enabled on jobs table
- [ ] All four policies created and active
- [ ] Public read access working for anonymous users
- [ ] Authenticated users can create jobs
- [ ] Users can only modify their own jobs
- [ ] Policies tested with multiple user scenarios
- [ ] Performance optimized with appropriate indexes
- [ ] Security audit completed
- [ ] Documentation created

## Common Troubleshooting

### Issue: Policies Not Working
```sql
-- Check if RLS is enabled
SELECT schemaname, tablename, rowsecurity 
FROM pg_tables 
WHERE tablename = 'jobs';

-- List all policies
SELECT * FROM pg_policies WHERE tablename = 'jobs';
```

### Issue: Performance Problems
```sql
-- Check query execution with RLS
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM jobs;
```

## Next Steps
After completing RLS setup:
1. Move to 1.3 Environment Configuration
2. Set up Supabase client in Next.js
3. Create TypeScript helpers for database operations