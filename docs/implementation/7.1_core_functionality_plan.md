# Phase 1: Core Functionality Implementation Plan
**Timeline: Week 1-2**

## üéØ Phase Overview
Establish the foundational infrastructure for job applications including database schema, basic CRUD operations, and minimal viable application flow.

## üìä Database Implementation

### Step 1.1: Create Migration Files

#### **File**: `supabase/migrations/20250831000001_create_user_profiles.sql`
```sql
-- Create user type enum
CREATE TYPE user_type_enum AS ENUM ('employer', 'job_seeker');

-- Create user profiles table
CREATE TABLE user_profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  user_type user_type_enum NOT NULL DEFAULT 'job_seeker',
  full_name TEXT,
  profile_data JSONB DEFAULT '{}',
  resume_file_path TEXT, -- Supabase storage file path
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id)
);

-- Create indexes
CREATE INDEX idx_user_profiles_user_id ON user_profiles(user_id);
CREATE INDEX idx_user_profiles_type ON user_profiles(user_type);

-- RLS Policies
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;

-- Users can only see and edit their own profile
CREATE POLICY "Users can view own profile" ON user_profiles
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can update own profile" ON user_profiles
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own profile" ON user_profiles
  FOR INSERT WITH CHECK (auth.uid() = user_id);
```

#### **File**: `supabase/migrations/20250831000002_create_job_applications.sql`
```sql
-- Create application status enum
CREATE TYPE application_status_enum AS ENUM ('pending', 'reviewing', 'shortlisted', 'rejected', 'accepted');

-- Create job applications table
CREATE TABLE job_applications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id UUID REFERENCES jobs(id) ON DELETE CASCADE,
  applicant_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  status application_status_enum DEFAULT 'pending',
  cover_letter TEXT,
  resume_file_path TEXT, -- Supabase storage file path
  applied_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(job_id, applicant_id) -- Prevent duplicate applications
);

-- Create indexes
CREATE INDEX idx_job_applications_job_id ON job_applications(job_id);
CREATE INDEX idx_job_applications_applicant_id ON job_applications(applicant_id);
CREATE INDEX idx_job_applications_status ON job_applications(status);
CREATE INDEX idx_job_applications_applied_at ON job_applications(applied_at DESC);

-- Add trigger for updated_at
CREATE TRIGGER update_job_applications_updated_at 
    BEFORE UPDATE ON job_applications 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

-- RLS Policies
ALTER TABLE job_applications ENABLE ROW LEVEL SECURITY;

-- Job seekers can view their own applications
CREATE POLICY "Users can view own applications" ON job_applications
  FOR SELECT USING (auth.uid() = applicant_id);

-- Job seekers can create applications
CREATE POLICY "Users can create applications" ON job_applications
  FOR INSERT WITH CHECK (auth.uid() = applicant_id);

-- Employers can view applications for their jobs
CREATE POLICY "Employers can view job applications" ON job_applications
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM jobs 
      WHERE jobs.id = job_applications.job_id 
      AND jobs.user_id = auth.uid()
    )
  );

-- Employers can update application status for their jobs
CREATE POLICY "Employers can update application status" ON job_applications
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM jobs 
      WHERE jobs.id = job_applications.job_id 
      AND jobs.user_id = auth.uid()
    )
  );
```

### Step 1.2: Update TypeScript Types

#### **File**: `types/database.ts` - Add new types
```typescript
// Add to existing file
export type UserProfile = Database['public']['Tables']['user_profiles']['Row']
export type UserProfileInsert = Database['public']['Tables']['user_profiles']['Insert']
export type UserProfileUpdate = Database['public']['Tables']['user_profiles']['Update']
export type UserType = Database['public']['Enums']['user_type_enum']

export type JobApplication = Database['public']['Tables']['job_applications']['Row']
export type JobApplicationInsert = Database['public']['Tables']['job_applications']['Insert']
export type JobApplicationUpdate = Database['public']['Tables']['job_applications']['Update']
export type ApplicationStatus = Database['public']['Enums']['application_status_enum']

// Extended types for joined queries
export type JobApplicationWithJob = JobApplication & {
  jobs: Job
}

export type JobApplicationWithProfile = JobApplication & {
  user_profiles: UserProfile
}
```

## üèóÔ∏è Backend Implementation

### Step 1.3: Database Operations

#### **File**: `src/lib/database/applications.ts`
```typescript
import { supabase } from '@/lib/supabase/client'
import { createClient as createServerClient } from '@/lib/supabase/server'
import type { JobApplicationInsert, JobApplicationUpdate, ApplicationStatus } from '@/types/database'

export interface ApplicationFilters {
  status?: ApplicationStatus[]
  job_id?: string
  applicant_id?: string
}

// Client-side operations
export const applicationsClient = {
  // Apply to a job
  async create(application: JobApplicationInsert) {
    const client = supabase()
    return client
      .from('job_applications')
      .insert(application)
      .select(`
        *,
        jobs (
          id,
          title,
          company,
          location,
          job_type
        )
      `)
      .single()
  },

  // Get user's applications
  async getByUser(userId: string, filters?: ApplicationFilters) {
    const client = supabase()
    let query = client
      .from('job_applications')
      .select(`
        *,
        jobs (
          id,
          title,
          company,
          location,
          job_type,
          status as job_status
        )
      `)
      .eq('applicant_id', userId)
      .order('applied_at', { ascending: false })

    if (filters?.status?.length) {
      query = query.in('status', filters.status)
    }

    return query
  },

  // Get applications for a job
  async getByJob(jobId: string, filters?: ApplicationFilters) {
    const client = supabase()
    let query = client
      .from('job_applications')
      .select(`
        *,
        user_profiles (
          full_name,
          user_type
        )
      `)
      .eq('job_id', jobId)
      .order('applied_at', { ascending: false })

    if (filters?.status?.length) {
      query = query.in('status', filters.status)
    }

    return query
  },

  // Check if user has already applied
  async hasApplied(jobId: string, userId: string) {
    const client = supabase()
    const { data, error } = await client
      .from('job_applications')
      .select('id')
      .eq('job_id', jobId)
      .eq('applicant_id', userId)
      .single()

    return { hasApplied: !!data && !error, error }
  }
}

// Server-side operations
export const applicationsServer = {
  // Apply to a job (server-side)
  async create(application: JobApplicationInsert) {
    const supabase = await createServerClient()
    return supabase
      .from('job_applications')
      .insert({
        ...application,
        applied_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select(`
        *,
        jobs (
          id,
          title,
          company,
          location,
          job_type
        )
      `)
      .single()
  },

  // Get user's applications with job details
  async getByUser(userId: string, filters?: ApplicationFilters) {
    const supabase = await createServerClient()
    let query = supabase
      .from('job_applications')
      .select(`
        *,
        jobs (
          id,
          title,
          company,
          location,
          job_type,
          status as job_status
        )
      `)
      .eq('applicant_id', userId)
      .order('applied_at', { ascending: false })

    if (filters?.status?.length) {
      query = query.in('status', filters.status)
    }

    return query
  },

  // Get applications for employer's job
  async getByJob(jobId: string, employerId: string, filters?: ApplicationFilters) {
    const supabase = await createServerClient()
    
    // First verify job ownership
    const { data: job } = await supabase
      .from('jobs')
      .select('user_id')
      .eq('id', jobId)
      .single()

    if (!job || job.user_id !== employerId) {
      return { data: null, error: { message: 'Unauthorized' } }
    }

    let query = supabase
      .from('job_applications')
      .select(`
        *,
        user_profiles (
          full_name,
          user_type
        )
      `)
      .eq('job_id', jobId)
      .order('applied_at', { ascending: false })

    if (filters?.status?.length) {
      query = query.in('status', filters.status)
    }

    return query
  },

  // Update application status
  async updateStatus(applicationId: string, status: ApplicationStatus, employerId: string) {
    const supabase = await createServerClient()
    
    // Verify employer can update this application
    const { data: application } = await supabase
      .from('job_applications')
      .select(`
        id,
        jobs!inner(user_id)
      `)
      .eq('id', applicationId)
      .single()

    if (!application || application.jobs.user_id !== employerId) {
      return { data: null, error: { message: 'Unauthorized' } }
    }

    return supabase
      .from('job_applications')
      .update({ 
        status,
        updated_at: new Date().toISOString()
      })
      .eq('id', applicationId)
      .select()
      .single()
  },

  // Check if user has applied
  async hasApplied(jobId: string, userId: string) {
    const supabase = await createServerClient()
    const { data, error } = await supabase
      .from('job_applications')
      .select('id')
      .eq('job_id', jobId)
      .eq('applicant_id', userId)
      .single()

    return { hasApplied: !!data && !error, error }
  }
}
```

### Step 1.4: User Profiles Operations

#### **File**: `src/lib/database/user-profiles.ts`
```typescript
import { supabase } from '@/lib/supabase/client'
import { createClient as createServerClient } from '@/lib/supabase/server'
import type { UserProfileInsert, UserProfileUpdate } from '@/types/database'

// Client-side operations
export const userProfilesClient = {
  async getByUserId(userId: string) {
    const client = supabase()
    return client
      .from('user_profiles')
      .select('*')
      .eq('user_id', userId)
      .single()
  },

  async create(profile: UserProfileInsert) {
    const client = supabase()
    return client
      .from('user_profiles')
      .insert(profile)
      .select()
      .single()
  },

  async update(userId: string, profile: UserProfileUpdate) {
    const client = supabase()
    return client
      .from('user_profiles')
      .update(profile)
      .eq('user_id', userId)
      .select()
      .single()
  }
}

// Server-side operations
export const userProfilesServer = {
  async getByUserId(userId: string) {
    const supabase = await createServerClient()
    return supabase
      .from('user_profiles')
      .select('*')
      .eq('user_id', userId)
      .single()
  },

  async create(profile: UserProfileInsert) {
    const supabase = await createServerClient()
    return supabase
      .from('user_profiles')
      .insert({
        ...profile,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single()
  },

  async update(userId: string, profile: UserProfileUpdate) {
    const supabase = await createServerClient()
    return supabase
      .from('user_profiles')
      .update({
        ...profile,
        updated_at: new Date().toISOString()
      })
      .eq('user_id', userId)
      .select()
      .single()
  }
}
```

### Step 1.5: Validation Schemas

#### **File**: `src/lib/schemas/application-schema.ts`
```typescript
import { z } from 'zod'

export const applicationSchema = z.object({
  job_id: z.string().uuid('Invalid job ID'),
  cover_letter: z
    .string()
    .min(50, 'Cover letter must be at least 50 characters')
    .max(2000, 'Cover letter must be less than 2000 characters'),
  resume_file_path: z
    .string()
    .optional() // File path from Supabase storage
})

export const applicationStatusUpdateSchema = z.object({
  application_id: z.string().uuid('Invalid application ID'),
  status: z.enum(['pending', 'reviewing', 'shortlisted', 'rejected', 'accepted'])
})

export const userProfileSchema = z.object({
  user_type: z.enum(['employer', 'job_seeker']),
  full_name: z
    .string()
    .min(2, 'Full name must be at least 2 characters')
    .max(100, 'Full name must be less than 100 characters'),
  profile_data: z.record(z.any()).optional(),
  resume_file_path: z
    .string()
    .optional() // Supabase storage path
})

export type ApplicationFormData = z.infer<typeof applicationSchema>
export type ApplicationStatusUpdate = z.infer<typeof applicationStatusUpdateSchema>
export type UserProfileFormData = z.infer<typeof userProfileSchema>
```

## üé® Frontend Implementation

### Step 1.6: Supabase Storage Setup

#### **File**: `supabase/migrations/20250831000003_setup_resume_storage.sql`
```sql
-- Create storage bucket for resumes
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types) 
VALUES (
  'resumes', 
  'resumes', 
  false, 
  2097152, -- 2MB limit
  ARRAY['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document']
);

-- RLS policies for resume storage
CREATE POLICY "Users can upload own resumes" ON storage.objects
FOR INSERT WITH CHECK (
  bucket_id = 'resumes' 
  AND auth.uid()::text = (storage.foldername(name))[1]
);

CREATE POLICY "Users can view own resumes" ON storage.objects
FOR SELECT USING (
  bucket_id = 'resumes' 
  AND auth.uid()::text = (storage.foldername(name))[1]
);

CREATE POLICY "Employers can view applicant resumes" ON storage.objects
FOR SELECT USING (
  bucket_id = 'resumes'
  AND EXISTS (
    SELECT 1 FROM job_applications ja
    JOIN jobs j ON ja.job_id = j.id
    WHERE j.user_id = auth.uid()
    AND ja.resume_file_path = name
  )
);

CREATE POLICY "Users can delete own resumes" ON storage.objects
FOR DELETE USING (
  bucket_id = 'resumes'
  AND auth.uid()::text = (storage.foldername(name))[1]
);
```

#### **File**: `src/lib/storage/resume-storage.ts`
```typescript
import { supabase } from '@/lib/supabase/client'
import { createClient as createServerClient } from '@/lib/supabase/server'

const BUCKET_NAME = 'resumes'
const MAX_FILE_SIZE = 2 * 1024 * 1024 // 2MB
const ALLOWED_TYPES = [
  'application/pdf', 
  'application/msword', 
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
]

export interface UploadResult {
  filePath?: string
  error?: string
}

// Client-side: Get presigned upload URL
export async function getResumeUploadUrl(userId: string, fileName: string): Promise<{ uploadUrl?: string, filePath?: string, error?: string }> {
  try {
    const client = supabase()
    const fileExt = fileName.split('.').pop()
    const sanitizedFileName = fileName.replace(/[^a-zA-Z0-9.-]/g, '_')
    const filePath = `${userId}/resume_${Date.now()}.${fileExt}`

    // Get presigned upload URL
    const { data, error } = await client.storage
      .from(BUCKET_NAME)
      .createSignedUploadUrl(filePath, {
        upsert: false
      })

    if (error) throw error

    return { 
      uploadUrl: data.signedUrl,
      filePath: filePath
    }
  } catch (error) {
    console.error('Error getting upload URL:', error)
    return { error: 'Failed to prepare file upload' }
  }
}

// Client-side: Upload file using presigned URL
export async function uploadResumeFile(
  file: File, 
  uploadUrl: string
): Promise<UploadResult> {
  try {
    // Validate file
    if (!ALLOWED_TYPES.includes(file.type)) {
      return { error: 'Invalid file type. Please upload PDF, DOC, or DOCX files only.' }
    }

    if (file.size > MAX_FILE_SIZE) {
      return { error: 'File size too large. Please upload files smaller than 2MB.' }
    }

    // Upload using presigned URL
    const response = await fetch(uploadUrl, {
      method: 'PUT',
      body: file,
      headers: {
        'Content-Type': file.type,
      },
    })

    if (!response.ok) {
      throw new Error(`Upload failed: ${response.statusText}`)
    }

    return {}
  } catch (error) {
    console.error('Resume upload error:', error)
    return { error: 'Failed to upload resume. Please try again.' }
  }
}

// Server-side: Get signed download URL
export async function getResumeDownloadUrl(filePath: string): Promise<{ url?: string, error?: string }> {
  try {
    const supabase = await createServerClient()
    
    const { data, error } = await supabase.storage
      .from(BUCKET_NAME)
      .createSignedUrl(filePath, 3600) // 1 hour expiry

    if (error) throw error

    return { url: data.signedUrl }
  } catch (error) {
    console.error('Error getting download URL:', error)
    return { error: 'Failed to get resume URL' }
  }
}

// Server-side: Delete resume file
export async function deleteResume(filePath: string): Promise<{ error?: string }> {
  try {
    const supabase = await createServerClient()
    const { error } = await supabase.storage
      .from(BUCKET_NAME)
      .remove([filePath])

    if (error) throw error
    return {}
  } catch (error) {
    console.error('Resume deletion error:', error)
    return { error: 'Failed to delete resume.' }
  }
}
```

### Step 1.7: Basic Apply Button

#### **File**: `src/components/jobs/apply-button.tsx`
```tsx
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { useAuth } from '@/lib/auth/context'
import { applicationsClient } from '@/lib/database/applications'
import { useToast } from '@/lib/toast-context'

interface ApplyButtonProps {
  jobId: string
  className?: string
}

export function ApplyButton({ jobId, className }: ApplyButtonProps) {
  const { user } = useAuth()
  const { toast } = useToast()
  const [isLoading, setIsLoading] = useState(false)
  const [hasApplied, setHasApplied] = useState(false)

  // Check if user has already applied (implement useEffect)
  // For Phase 1, we'll keep it simple

  const handleApply = async () => {
    if (!user) {
      toast({
        title: 'Authentication Required',
        description: 'Please sign in to apply for jobs.',
        type: 'error'
      })
      return
    }

    setIsLoading(true)
    try {
      // Simple application without cover letter for Phase 1
      const { error } = await applicationsClient.create({
        job_id: jobId,
        applicant_id: user.id,
        cover_letter: '', // Empty for Phase 1
        status: 'pending'
      })

      if (error) throw error

      setHasApplied(true)
      toast({
        title: 'Application Submitted',
        description: 'Your application has been submitted successfully!',
        type: 'success'
      })
    } catch (error) {
      toast({
        title: 'Application Failed',
        description: error.message || 'Failed to submit application',
        type: 'error'
      })
    } finally {
      setIsLoading(false)
    }
  }

  if (hasApplied) {
    return (
      <Button disabled className={className}>
        Applied
      </Button>
    )
  }

  return (
    <Button
      onClick={handleApply}
      loading={isLoading}
      className={className}
    >
      Apply Now
    </Button>
  )
}
```

### Step 1.7: My Applications Page

#### **File**: `src/app/dashboard/applications/page.tsx`
```tsx
import { Suspense } from 'react'
import { redirect } from 'next/navigation'
import { createServerClient } from '@/lib/supabase/server'
import { applicationsServer } from '@/lib/database/applications'
import { ApplicationsList } from '@/components/applications/applications-list'
import { LoadingSkeleton } from '@/components/loading/applications-skeleton'

export const metadata = {
  title: 'My Applications - Job Board',
  description: 'Track your job applications'
}

export default async function MyApplicationsPage() {
  const supabase = await createServerClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) {
    redirect('/auth/login')
  }

  const { data: applications, error } = await applicationsServer.getByUser(user.id)

  if (error) {
    throw new Error('Failed to load applications')
  }

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-2xl font-bold">My Applications</h1>
        <p className="text-muted-foreground">
          Track the status of your job applications
        </p>
      </div>

      <Suspense fallback={<LoadingSkeleton />}>
        <ApplicationsList applications={applications || []} />
      </Suspense>
    </div>
  )
}
```

### Step 1.8: Applications List Component

#### **File**: `src/components/applications/applications-list.tsx`
```tsx
import { Badge } from '@/components/ui/badge'
import { Card } from '@/components/ui/card'
import { formatDistanceToNow } from 'date-fns'
import type { JobApplicationWithJob } from '@/types/database'

interface ApplicationsListProps {
  applications: JobApplicationWithJob[]
}

export function ApplicationsList({ applications }: ApplicationsListProps) {
  if (applications.length === 0) {
    return (
      <div className="text-center py-12">
        <h3 className="text-lg font-semibold">No applications yet</h3>
        <p className="text-muted-foreground">
          Start browsing jobs and submit your first application!
        </p>
      </div>
    )
  }

  return (
    <div className="space-y-4">
      {applications.map((application) => (
        <Card key={application.id} className="p-6">
          <div className="flex items-start justify-between">
            <div className="space-y-2">
              <h3 className="font-semibold text-lg">
                {application.jobs.title}
              </h3>
              <p className="text-muted-foreground">
                {application.jobs.company} ‚Ä¢ {application.jobs.location}
              </p>
              <p className="text-sm text-muted-foreground">
                Applied {formatDistanceToNow(new Date(application.applied_at), { addSuffix: true })}
              </p>
            </div>
            
            <div className="flex flex-col items-end gap-2">
              <ApplicationStatusBadge status={application.status} />
              <Badge variant="outline">
                {application.jobs.job_type}
              </Badge>
            </div>
          </div>
        </Card>
      ))}
    </div>
  )
}

// Resume Download Component
function ResumeDownloadLink({ filePath }: { filePath: string }) {
  const [downloadUrl, setDownloadUrl] = useState<string>('')
  const [loading, setLoading] = useState(false)

  const handleDownload = async () => {
    setLoading(true)
    try {
      const { url, error } = await getResumeDownloadUrl(filePath)
      if (error) throw new Error(error)
      if (url) {
        window.open(url, '_blank')
      }
    } catch (error) {
      console.error('Failed to download resume:', error)
    } finally {
      setLoading(false)
    }
  }

  return (
    <button
      onClick={handleDownload}
      disabled={loading}
      className="inline-flex items-center gap-1 text-blue-600 hover:text-blue-700 disabled:opacity-50"
    >
      <FileText className="h-3 w-3" />
      {loading ? 'Loading...' : 'Resume'}
      <ExternalLink className="h-3 w-3" />
    </button>
  )
}

function ApplicationStatusBadge({ status }: { status: string }) {
  const variants = {
    pending: 'default',
    reviewing: 'secondary',
    shortlisted: 'success',
    rejected: 'destructive',
    accepted: 'success'
  } as const

  return (
    <Badge variant={variants[status] || 'default'}>
      {status.charAt(0).toUpperCase() + status.slice(1)}
    </Badge>
  )
}
```

## üìù Testing Implementation

### Step 1.9: Basic Database Tests

#### **File**: `src/lib/database/__tests__/applications.test.ts`
```typescript
import { describe, it, expect, beforeEach, afterEach } from 'jest'
import { applicationsServer } from '../applications'
import { createTestUser, createTestJob, cleanupTestData } from '@/lib/test-setup'

describe('Applications Database Operations', () => {
  let testUser: any
  let testJob: any

  beforeEach(async () => {
    testUser = await createTestUser()
    testJob = await createTestJob(testUser.id)
  })

  afterEach(async () => {
    await cleanupTestData()
  })

  it('should create a new application', async () => {
    const application = {
      job_id: testJob.id,
      applicant_id: testUser.id,
      cover_letter: 'Test cover letter',
      status: 'pending' as const
    }

    const { data, error } = await applicationsServer.create(application)

    expect(error).toBeNull()
    expect(data).toBeDefined()
    expect(data?.job_id).toBe(testJob.id)
    expect(data?.applicant_id).toBe(testUser.id)
  })

  it('should get applications by user', async () => {
    // Create test application first
    await applicationsServer.create({
      job_id: testJob.id,
      applicant_id: testUser.id,
      cover_letter: 'Test',
      status: 'pending'
    })

    const { data, error } = await applicationsServer.getByUser(testUser.id)

    expect(error).toBeNull()
    expect(data).toBeDefined()
    expect(data?.length).toBe(1)
  })
})
```

## ‚úÖ Phase 1 Completion Criteria

- [ ] Database migrations successfully applied
- [ ] User profiles table created with proper RLS
- [ ] Job applications table created with relationships
- [ ] Basic CRUD operations working for applications
- [ ] Apply button functional on job detail pages
- [ ] My Applications page displays user's applications
- [ ] Basic status badges showing application status
- [ ] Unit tests passing for core database operations
- [ ] No authentication/authorization vulnerabilities
- [ ] Clean error handling throughout the flow

## üîÑ Integration Points

### Navigation Updates
- Add "My Applications" link to dashboard sidebar
- Update dashboard layout to include applications section

### Job Detail Page Updates
- Add ApplyButton component to job detail pages
- Show application status if user has already applied

### Database Seeding
- Create seed data for testing user profiles
- Create sample applications for development

## üìã Deliverables

1. **Database Schema**: Complete migrations with RLS policies
2. **Backend Operations**: Full CRUD functionality for applications
3. **Basic UI Components**: Apply button and applications list
4. **Application Pages**: My Applications dashboard page
5. **Unit Tests**: Core database operations covered
6. **Documentation**: API documentation for new endpoints

This phase establishes the foundation for the job application system with minimal but functional features that can be immediately tested and used.